<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>slider.PredictionSample API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>slider.PredictionSample</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np

def predictionSample(fullMetrics, failureIndices, timeArr=None, desiredOutcome=None, sampleLength=20, downsampleFactor=None, randomSeed=21):
    &#34;&#34;&#34;
    Sample either failures or non-failures (or both) for a trial or set of trials.

    Parameters
    ----------

    fullMetrics : numpy.ndarray or list
        A list or array of values that represent a set of metrics evaluated for a complete trial,
        or a set of trials.
        eg. [[[m1(0,0), m1(0,1), ...], [m2(0,0), m2(0,1), ...]], [[m1(1,0), m1(1,1), ...], [m2(1,0), m2(1,1), ...]]]

    forcePeakIndices : list(int) or numpy.ndarray(int)
        A collection of indices that represent when failure happens, or a list of such collections.

    timeArr : list(float) or numpy.ndarray
        The time axis for the set of metrics, and that correspond to the failureIndices. If this is passed, the resultant
        array will include times as the last element.

    desiredOutcome : int or bool or None
        Whether to sample a particlular trial: samples with failure (1, True) or without failure (0, False). If sampling
        without failure, will randomly generate as many samples as there are failures in failureIndices. If None,
        will return an equal amount of both failure and non-failure samples.

    sampleLength : int
        The length of each sample, in number of frames or time steps. If downsampling (see downsampleFactor), the length of
        samples will be exactly this value, though the timesteps will be more spaced out.

    downsampleFactor : int or None
        The degree to which we should downsample the data.

    randomSeed : int
        The seed to random generation, which is required for generating the non-failure samples


    Returns
    -------

    numpy.ndarray : Array of shape (numSamples, len(fullMetrics), sampleLength) or (numSamples, len(fullMetrics)+1, sampleLength),
        depending on whether a timeArr is passed to the method. The entries in the middle dimension correspond to
        the metrics that are provided, and possibly the time. numSamples is determined by the total number of positive events in the interval.

        list(i,0,:): 0th metric for ith sample
        list(i,1,:): 1st metric for ith sample
        list(i,2,:): 2nd metric for ith sample
        ...
        list(i,-1,:): time axis for ith sample (if timeArr != None)
    &#34;&#34;&#34;

    # If the first element of the list of indices is not a list itself, we only have
    # a single trial
    if not isinstance(failureIndices[0], np.ndarray) and not isinstance(failureIndices[0], list):
        # Handle this so we don&#39;t have to catch None later
        if downsampleFactor == None:
            downsampleFactor = 1

        # First, generate the positive samples since they are predetermined by the locations
        # of the failures

        # Make sure that there aren&#39;t any failures that are too close to each other
        minDistance = (sampleLength+1)*downsampleFactor

        # If we do have an overlap, we&#39;ll have to get rid of one of the failures
        # We want to take the one that doesn&#39;t have another failure in the middle of it, which
        # amounts to being the first one
        # We always include the first failure
        confirmedFailureIndices = [failureIndices[0]] + [failureIndices[i] for i in range(1, len(failureIndices)) if failureIndices[i]-failureIndices[i-1] &gt; minDistance]
        # Adjust for the downsampling factor
        # For the failure indices, we just divide by the factor (and cast to int)
        confirmedFailureIndices = np.array([int(i/downsampleFactor) for i in confirmedFailureIndices])
        # For the metrics, we just use index slicing
        downsampledFullMetrics = np.array([metric[::downsampleFactor] for metric in fullMetrics])

        hasTimeArr = isinstance(timeArr, list) or isinstance(timeArr, np.ndarray)
        if hasTimeArr:
            downsampledTimeArr = timeArr[::downsampleFactor]

        failureInputArr = []
        inputArrLen = len(fullMetrics) + int(hasTimeArr)
        numTimeSteps = len(downsampledFullMetrics[0])

        # Note that we count backwards here, since we remove times that interfere with others
        for i in range(len(confirmedFailureIndices)):

            # Now we add this point to the data

            # Find the closest point in the time of the video
            # -1 for the same reason as the sampleLength+1 above, since the failure should be *after* the last interval
            endIndex = confirmedFailureIndices[i] - 1
            beginIndex = endIndex - sampleLength
            currInputArr = np.zeros([inputArrLen, sampleLength])

            for j in range(len(downsampledFullMetrics)):
                currInputArr[j,:] = downsampledFullMetrics[j,beginIndex:endIndex]

            if hasTimeArr:
                currInputArr[-1,:] = downsampledTimeArr[beginIndex:endIndex]

            failureInputArr.append(currInputArr)


        # The inputs (for our model eventually) are the metrics, and the outputs will be one
        # since a failure happens in the interval
        failureInputArr = np.array(failureInputArr) 
        failureOutputArr = np.ones(len(failureInputArr))
    
        # Return if we only wanted failure samples
        if desiredOutcome == True or desiredOutcome == 1:
            return (failureInputArr, failureOutputArr)

        # Now create an equal number of negative samples

        # See return type explanation above for why it has this shape
        nonfailureInputArr = np.zeros([len(failureInputArr), inputArrLen, sampleLength])

        i = 0
        # Seed our random generation, so we can test with consistent results
        np.random.seed(randomSeed)
        while i &lt; np.shape(nonfailureInputArr)[0]:

            # Randomly generate an interval of time for the video 
            randomBeginIndex = np.random.randint(0, numTimeSteps - sampleLength)
            #randomStartFrame = 100 # TESTING, remove later
            endIndex = randomBeginIndex + sampleLength

            # Crop the full array down to the sample
            for j in range(len(downsampledFullMetrics)):
                nonfailureInputArr[i,j,:] = downsampledFullMetrics[j,randomBeginIndex:endIndex]

            if hasTimeArr:
                nonfailureInputArr[i,-1,:] = downsampledTimeArr[randomBeginIndex:endIndex]

            # Next, we have to determine if a failure event happens anywhere in the interval

            # Fancy way to search for a time between our requested interval. I am not sure if this is actually
            # faster than a regular search, but it is reasonably easy to implement
            failureInInterval = True in ((confirmedFailureIndices - randomBeginIndex)[confirmedFailureIndices - randomBeginIndex &gt; 0] &lt; sampleLength)
            #print((eventArr - failureIntervalStart)[eventArr - failureIntervalStart &gt; 0])
            #print(failureInInterval)
            
            # Assuming there is not a failure, we move on the next
            # Otherwise, the loop repeats and we replace this current one
            if not failureInInterval:
                i += 1

        nonfailureOutputArr = np.zeros(len(nonfailureInputArr))
 
        # Return if we only wanted nonfailure samples
        if desiredOutcome == False or desiredOutcome == 0:
            return (nonfailureInputArr, nonfailureOutputArr)

        # Now concatenate the two inputs
        fullInputArr = np.zeros([np.shape(failureInputArr)[0]*2, inputArrLen, sampleLength])
        fullInputArr[:np.shape(failureInputArr)[0],:,:] = failureInputArr
        fullInputArr[np.shape(nonfailureInputArr)[0]:,:,:] = nonfailureInputArr
        fullOutputArr = np.append(failureOutputArr, nonfailureOutputArr)

        # And randomly rearrange them
        randomOrder = np.arange(0, np.shape(fullInputArr)[0])
        np.random.shuffle(randomOrder)

        fullInputArr = fullInputArr[randomOrder]
        fullOutputArr = fullOutputArr[randomOrder]

        return (fullInputArr, fullOutputArr)

    # Do the usual vectorization method using recursion
    # We loop through every video and append the results to the master list
    inputArr = []
    outputArr = []

    for i in range(len(fullMetrics)):

        # We have to catch any None type issues, since otherwise we&#39;ll
        # try to index None
        if isinstance(timeArr, list) or isinstance(timeArr, np.ndarray):
            currTimeArr = timeArr[i]
        else:
            currTimeArr = None
        currInputArr, currOutputArr = predictionSample(fullMetrics[i], failureIndices[i], timeArr=currTimeArr,
                                                       desiredOutcome=desiredOutcome, sampleLength=sampleLength, downsampleFactor=downsampleFactor,
                                                       randomSeed=randomSeed)
        inputArr.append(currInputArr)
        outputArr.append(currOutputArr)

    inputArrLen = len(fullMetrics[0]) + int(isinstance(timeArr, list))
    totalSamples = sum([len(inputArr[i]) for i in range(len(inputArr))])
    reshapedInputArr = np.zeros([totalSamples, inputArrLen, sampleLength])
    reshapedOutputArr = np.zeros(totalSamples)

    currIndex = 0

    for i in range(len(inputArr)):
        reshapedInputArr[currIndex:currIndex+len(inputArr[i])] = np.array(inputArr[i])
        reshapedOutputArr[currIndex:currIndex+len(inputArr[i])] = np.array(outputArr[i])
        
        currIndex += len(inputArr[i])
    return (reshapedInputArr, reshapedOutputArr)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="slider.PredictionSample.predictionSample"><code class="name flex">
<span>def <span class="ident">predictionSample</span></span>(<span>fullMetrics, failureIndices, timeArr=None, desiredOutcome=None, sampleLength=20, downsampleFactor=None, randomSeed=21)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample either failures or non-failures (or both) for a trial or set of trials.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fullMetrics</code></strong> :&ensp;<code>numpy.ndarray</code> or <code>list</code></dt>
<dd>A list or array of values that represent a set of metrics evaluated for a complete trial,
or a set of trials.
eg. [[[m1(0,0), m1(0,1), &hellip;], [m2(0,0), m2(0,1), &hellip;]], [[m1(1,0), m1(1,1), &hellip;], [m2(1,0), m2(1,1), &hellip;]]]</dd>
<dt><strong><code>forcePeakIndices</code></strong> :&ensp;<code>list(int)</code> or <code>numpy.ndarray(int)</code></dt>
<dd>A collection of indices that represent when failure happens, or a list of such collections.</dd>
<dt><strong><code>timeArr</code></strong> :&ensp;<code>list(float)</code> or <code>numpy.ndarray</code></dt>
<dd>The time axis for the set of metrics, and that correspond to the failureIndices. If this is passed, the resultant
array will include times as the last element.</dd>
<dt><strong><code>desiredOutcome</code></strong> :&ensp;<code>int</code> or <code>bool</code> or <code>None</code></dt>
<dd>Whether to sample a particlular trial: samples with failure (1, True) or without failure (0, False). If sampling
without failure, will randomly generate as many samples as there are failures in failureIndices. If None,
will return an equal amount of both failure and non-failure samples.</dd>
<dt><strong><code>sampleLength</code></strong> :&ensp;<code>int</code></dt>
<dd>The length of each sample, in number of frames or time steps. If downsampling (see downsampleFactor), the length of
samples will be exactly this value, though the timesteps will be more spaced out.</dd>
<dt><strong><code>downsampleFactor</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>The degree to which we should downsample the data.</dd>
<dt><strong><code>randomSeed</code></strong> :&ensp;<code>int</code></dt>
<dd>The seed to random generation, which is required for generating the non-failure samples</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray : Array</code> of <code>shape (numSamples, len(fullMetrics), sampleLength)</code> or <code>(numSamples, len(fullMetrics)+1, sampleLength),</code></dt>
<dd>
<p>depending on whether a timeArr is passed to the method. The entries in the middle dimension correspond to
the metrics that are provided, and possibly the time. numSamples is determined by the total number of positive events in the interval.</p>
<p>list(i,0,:): 0th metric for ith sample
list(i,1,:): 1st metric for ith sample
list(i,2,:): 2nd metric for ith sample
&hellip;
list(i,-1,:): time axis for ith sample (if timeArr != None)</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predictionSample(fullMetrics, failureIndices, timeArr=None, desiredOutcome=None, sampleLength=20, downsampleFactor=None, randomSeed=21):
    &#34;&#34;&#34;
    Sample either failures or non-failures (or both) for a trial or set of trials.

    Parameters
    ----------

    fullMetrics : numpy.ndarray or list
        A list or array of values that represent a set of metrics evaluated for a complete trial,
        or a set of trials.
        eg. [[[m1(0,0), m1(0,1), ...], [m2(0,0), m2(0,1), ...]], [[m1(1,0), m1(1,1), ...], [m2(1,0), m2(1,1), ...]]]

    forcePeakIndices : list(int) or numpy.ndarray(int)
        A collection of indices that represent when failure happens, or a list of such collections.

    timeArr : list(float) or numpy.ndarray
        The time axis for the set of metrics, and that correspond to the failureIndices. If this is passed, the resultant
        array will include times as the last element.

    desiredOutcome : int or bool or None
        Whether to sample a particlular trial: samples with failure (1, True) or without failure (0, False). If sampling
        without failure, will randomly generate as many samples as there are failures in failureIndices. If None,
        will return an equal amount of both failure and non-failure samples.

    sampleLength : int
        The length of each sample, in number of frames or time steps. If downsampling (see downsampleFactor), the length of
        samples will be exactly this value, though the timesteps will be more spaced out.

    downsampleFactor : int or None
        The degree to which we should downsample the data.

    randomSeed : int
        The seed to random generation, which is required for generating the non-failure samples


    Returns
    -------

    numpy.ndarray : Array of shape (numSamples, len(fullMetrics), sampleLength) or (numSamples, len(fullMetrics)+1, sampleLength),
        depending on whether a timeArr is passed to the method. The entries in the middle dimension correspond to
        the metrics that are provided, and possibly the time. numSamples is determined by the total number of positive events in the interval.

        list(i,0,:): 0th metric for ith sample
        list(i,1,:): 1st metric for ith sample
        list(i,2,:): 2nd metric for ith sample
        ...
        list(i,-1,:): time axis for ith sample (if timeArr != None)
    &#34;&#34;&#34;

    # If the first element of the list of indices is not a list itself, we only have
    # a single trial
    if not isinstance(failureIndices[0], np.ndarray) and not isinstance(failureIndices[0], list):
        # Handle this so we don&#39;t have to catch None later
        if downsampleFactor == None:
            downsampleFactor = 1

        # First, generate the positive samples since they are predetermined by the locations
        # of the failures

        # Make sure that there aren&#39;t any failures that are too close to each other
        minDistance = (sampleLength+1)*downsampleFactor

        # If we do have an overlap, we&#39;ll have to get rid of one of the failures
        # We want to take the one that doesn&#39;t have another failure in the middle of it, which
        # amounts to being the first one
        # We always include the first failure
        confirmedFailureIndices = [failureIndices[0]] + [failureIndices[i] for i in range(1, len(failureIndices)) if failureIndices[i]-failureIndices[i-1] &gt; minDistance]
        # Adjust for the downsampling factor
        # For the failure indices, we just divide by the factor (and cast to int)
        confirmedFailureIndices = np.array([int(i/downsampleFactor) for i in confirmedFailureIndices])
        # For the metrics, we just use index slicing
        downsampledFullMetrics = np.array([metric[::downsampleFactor] for metric in fullMetrics])

        hasTimeArr = isinstance(timeArr, list) or isinstance(timeArr, np.ndarray)
        if hasTimeArr:
            downsampledTimeArr = timeArr[::downsampleFactor]

        failureInputArr = []
        inputArrLen = len(fullMetrics) + int(hasTimeArr)
        numTimeSteps = len(downsampledFullMetrics[0])

        # Note that we count backwards here, since we remove times that interfere with others
        for i in range(len(confirmedFailureIndices)):

            # Now we add this point to the data

            # Find the closest point in the time of the video
            # -1 for the same reason as the sampleLength+1 above, since the failure should be *after* the last interval
            endIndex = confirmedFailureIndices[i] - 1
            beginIndex = endIndex - sampleLength
            currInputArr = np.zeros([inputArrLen, sampleLength])

            for j in range(len(downsampledFullMetrics)):
                currInputArr[j,:] = downsampledFullMetrics[j,beginIndex:endIndex]

            if hasTimeArr:
                currInputArr[-1,:] = downsampledTimeArr[beginIndex:endIndex]

            failureInputArr.append(currInputArr)


        # The inputs (for our model eventually) are the metrics, and the outputs will be one
        # since a failure happens in the interval
        failureInputArr = np.array(failureInputArr) 
        failureOutputArr = np.ones(len(failureInputArr))
    
        # Return if we only wanted failure samples
        if desiredOutcome == True or desiredOutcome == 1:
            return (failureInputArr, failureOutputArr)

        # Now create an equal number of negative samples

        # See return type explanation above for why it has this shape
        nonfailureInputArr = np.zeros([len(failureInputArr), inputArrLen, sampleLength])

        i = 0
        # Seed our random generation, so we can test with consistent results
        np.random.seed(randomSeed)
        while i &lt; np.shape(nonfailureInputArr)[0]:

            # Randomly generate an interval of time for the video 
            randomBeginIndex = np.random.randint(0, numTimeSteps - sampleLength)
            #randomStartFrame = 100 # TESTING, remove later
            endIndex = randomBeginIndex + sampleLength

            # Crop the full array down to the sample
            for j in range(len(downsampledFullMetrics)):
                nonfailureInputArr[i,j,:] = downsampledFullMetrics[j,randomBeginIndex:endIndex]

            if hasTimeArr:
                nonfailureInputArr[i,-1,:] = downsampledTimeArr[randomBeginIndex:endIndex]

            # Next, we have to determine if a failure event happens anywhere in the interval

            # Fancy way to search for a time between our requested interval. I am not sure if this is actually
            # faster than a regular search, but it is reasonably easy to implement
            failureInInterval = True in ((confirmedFailureIndices - randomBeginIndex)[confirmedFailureIndices - randomBeginIndex &gt; 0] &lt; sampleLength)
            #print((eventArr - failureIntervalStart)[eventArr - failureIntervalStart &gt; 0])
            #print(failureInInterval)
            
            # Assuming there is not a failure, we move on the next
            # Otherwise, the loop repeats and we replace this current one
            if not failureInInterval:
                i += 1

        nonfailureOutputArr = np.zeros(len(nonfailureInputArr))
 
        # Return if we only wanted nonfailure samples
        if desiredOutcome == False or desiredOutcome == 0:
            return (nonfailureInputArr, nonfailureOutputArr)

        # Now concatenate the two inputs
        fullInputArr = np.zeros([np.shape(failureInputArr)[0]*2, inputArrLen, sampleLength])
        fullInputArr[:np.shape(failureInputArr)[0],:,:] = failureInputArr
        fullInputArr[np.shape(nonfailureInputArr)[0]:,:,:] = nonfailureInputArr
        fullOutputArr = np.append(failureOutputArr, nonfailureOutputArr)

        # And randomly rearrange them
        randomOrder = np.arange(0, np.shape(fullInputArr)[0])
        np.random.shuffle(randomOrder)

        fullInputArr = fullInputArr[randomOrder]
        fullOutputArr = fullOutputArr[randomOrder]

        return (fullInputArr, fullOutputArr)

    # Do the usual vectorization method using recursion
    # We loop through every video and append the results to the master list
    inputArr = []
    outputArr = []

    for i in range(len(fullMetrics)):

        # We have to catch any None type issues, since otherwise we&#39;ll
        # try to index None
        if isinstance(timeArr, list) or isinstance(timeArr, np.ndarray):
            currTimeArr = timeArr[i]
        else:
            currTimeArr = None
        currInputArr, currOutputArr = predictionSample(fullMetrics[i], failureIndices[i], timeArr=currTimeArr,
                                                       desiredOutcome=desiredOutcome, sampleLength=sampleLength, downsampleFactor=downsampleFactor,
                                                       randomSeed=randomSeed)
        inputArr.append(currInputArr)
        outputArr.append(currOutputArr)

    inputArrLen = len(fullMetrics[0]) + int(isinstance(timeArr, list))
    totalSamples = sum([len(inputArr[i]) for i in range(len(inputArr))])
    reshapedInputArr = np.zeros([totalSamples, inputArrLen, sampleLength])
    reshapedOutputArr = np.zeros(totalSamples)

    currIndex = 0

    for i in range(len(inputArr)):
        reshapedInputArr[currIndex:currIndex+len(inputArr[i])] = np.array(inputArr[i])
        reshapedOutputArr[currIndex:currIndex+len(inputArr[i])] = np.array(outputArr[i])
        
        currIndex += len(inputArr[i])
    return (reshapedInputArr, reshapedOutputArr)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="slider" href="index.html">slider</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="slider.PredictionSample.predictionSample" href="#slider.PredictionSample.predictionSample">predictionSample</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>